from pathlib import Path
import ctypes
import os


if not os.environ.get("PATH_LIB_NDI"):
    PATH_LIB_NDI = Path(os.environ.get("ProgramFiles")).joinpath("NDI", "NDI 6 Tools", "Runtime", "Processing.NDI.Lib.x64.dll")
else:
    PATH_LIB_NDI = Path(os.environ["PATH_LIB_NDI"])
print(f"set `PATH_LIB_NDI` to {PATH_LIB_NDI}")


NDI = ctypes.CDLL(PATH_LIB_NDI.as_posix())


NDI.NDIlib_initialize.argtypes = []
NDI.NDIlib_initialize.restype = ctypes.c_bool


NDI.NDIlib_destroy.argtypes = []
NDI.NDIlib_destroy.restype = None


NDIlib_send_instance_t = ctypes.c_void_p


class NDIlib_send_create_t(ctypes.Structure):
    """
    The creation structure that is used when you are creating a sender.

    This struct is from `Processing.NDI.Send.h`
    """

    _fields_ = [
        # The name of the NDI source to create. This is a NULL terminated UTF8 string.
        ("p_ndi_name", ctypes.c_char_p),

        # What groups should this source be part of. NULL means default.
        ("p_groups", ctypes.c_char_p),

        # Do you want audio and video to "clock" themselves. When they are clocked then by adding video frames,
        # they will be rate limited to match the current frame rate that you are submitting at. The same is true
        # for audio. In general if you are submitting video and audio off a single thread then you should only
        # clock one of them (video is probably the better of the two to clock off). If you are submitting audio
        # and video of separate threads then having both clocked can be useful.
        ("clock_video", ctypes.c_int), ("clock_audio", ctypes.c_int),
    ]


NDI.NDIlib_send_create.argtypes = [ctypes.POINTER(NDIlib_send_create_t)]
NDI.NDIlib_send_create.restype = NDIlib_send_instance_t


NDI.NDIlib_send_destroy.argtypes = [NDIlib_send_instance_t]
NDI.NDIlib_send_destroy.restype = None


class NDIlib_video_frame_v2_t(ctypes.Structure):
    """
    This describes a video frame.

    This struct is from `Processing.NDI.structs.h`
    """

    _fields_ = [
        # The resolution of this frame.
        ("xres", ctypes.c_int), ("yres", ctypes.c_int),

        # What FourCC describing the type of data for this frame.
        # Check out `typedef enum NDIlib_FourCC_video_type_e`
        ("FourCC", ctypes.c_uint32),

        # What is the frame rate of this frame.
        # For instance NTSC is 30000,1001 = 30000/1001 = 29.97 fps.
        ("frame_rate_N", ctypes.c_int), ("frame_rate_D", ctypes.c_int),

        # What is the picture aspect ratio of this frame.
        # For instance 16.0/9.0 = 1.778 is 16:9 video
        # 0 means square pixels.
        ("picture_aspect_ratio", ctypes.c_float),

        # Is this a fielded frame, or is it progressive.
        # Check out `typedef enum NDIlib_frame_format_type_e`
        ("frame_format_type", ctypes.c_int),

        # The timecode of this frame in 100-nanosecond intervals.
        ("timecode", ctypes.c_int64),

        # The video data itself.
        ("p_data", ctypes.POINTER(ctypes.c_uint8)),

        # If the FourCC is not a compressed type, then this will be the inter-line stride of the video data
        # in bytes. If the stride is 0, then it will default to sizeof(one pixel)*xres.
        # If the FourCC is a compressed type, then this will be the size of the p_data buffer in bytes.
        # union { int line_stride_in_bytes; int line_stride_in_bytes_compressed; };
        ("line_stride_in_bytes", ctypes.c_int),

        # Per frame metadata for this frame. This is a NULL terminated UTF8 string that should be in XML format.
        # If you do not want any metadata then you may specify NULL here.
        ("p_metadata", ctypes.c_char_p),

        # This is only valid when receiving a frame and is specified as a 100-nanosecond time that was the exact
        # moment that the frame was submitted by the sending side and is generated by the SDK. If this value is
        # NDIlib_recv_timestamp_undefined then this value is not available and is NDIlib_recv_timestamp_undefined.
        ("timestamp", ctypes.c_int64), # Present in >= v2.5``
    ]


NDI.NDIlib_send_send_video.argtypes = [NDIlib_send_instance_t, ctypes.POINTER(NDIlib_video_frame_v2_t)]
NDI.NDIlib_send_send_video.restype = None
